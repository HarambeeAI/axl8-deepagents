"""Claude Skills integration for document generation.

This module provides Claude Skills capabilities (xlsx, pptx, pdf, docx generation)
as an additional feature alongside the existing Deep Agent functionality.

Skills are enabled via Anthropic's beta API and provide native document generation
capabilities within Claude's execution environment.
"""

import os
import json
import uuid
import asyncio
import httpx
import base64
from typing import AsyncGenerator, Optional, List, Dict, Any
from dataclasses import dataclass, field
from enum import Enum


class SkillType(str, Enum):
    """Available Claude Skills for document generation."""
    XLSX = "xlsx"
    PPTX = "pptx"
    PDF = "pdf"
    DOCX = "docx"


@dataclass
class GeneratedFile:
    """Represents a file generated by Claude Skills."""
    file_id: str
    file_name: str
    skill: Optional[SkillType] = None
    download_url: Optional[str] = None
    content: Optional[bytes] = None
    content_type: Optional[str] = None


@dataclass
class SkillsConfig:
    """Configuration for Claude Skills API."""
    api_key: str
    model: str = "claude-sonnet-4-5-20250929"
    max_tokens: int = 16000
    skills: List[SkillType] = field(default_factory=lambda: [
        SkillType.XLSX, SkillType.PPTX, SkillType.PDF, SkillType.DOCX
    ])


class ClaudeSkillsClient:
    """Client for interacting with Claude Skills API.
    
    This client handles:
    - Sending requests with skills enabled
    - Streaming responses with SSE
    - Downloading generated files from Claude Files API
    """
    
    ANTHROPIC_API_URL = "https://api.anthropic.com/v1/messages"
    ANTHROPIC_FILES_URL = "https://api.anthropic.com/v1/files"
    
    # Beta headers required for skills
    BETA_FEATURES = "code-execution-2025-08-25,skills-2025-10-02,files-api-2025-04-14"
    
    # Content type mapping
    CONTENT_TYPES = {
        "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        "pdf": "application/pdf",
        "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    }
    
    def __init__(self, config: SkillsConfig):
        self.config = config
        self.client = httpx.AsyncClient(timeout=300.0)
    
    def _get_headers(self) -> Dict[str, str]:
        """Get headers for Anthropic API requests."""
        return {
            "Content-Type": "application/json",
            "x-api-key": self.config.api_key,
            "anthropic-version": "2023-06-01",
            "anthropic-beta": self.BETA_FEATURES,
        }
    
    def _build_request_body(
        self,
        messages: List[Dict[str, Any]],
        system_prompt: Optional[str] = None,
        stream: bool = True,
    ) -> Dict[str, Any]:
        """Build the request body with skills configuration."""
        body = {
            "model": self.config.model,
            "max_tokens": self.config.max_tokens,
            "messages": messages,
            "stream": stream,
            # Skills configuration
            "container": {
                "skills": [
                    {"type": "anthropic", "skill_id": skill.value, "version": "latest"}
                    for skill in self.config.skills
                ]
            },
            # Code execution tool for skills
            "tools": [
                {"type": "code_execution_20250825", "name": "code_execution"}
            ],
        }
        
        if system_prompt:
            body["system"] = system_prompt
        
        return body
    
    async def download_file(self, file_id: str) -> tuple[bytes, str]:
        """Download a file from Claude Files API.
        
        Args:
            file_id: The Claude file ID to download.
            
        Returns:
            Tuple of (file content as bytes, content type).
        """
        url = f"{self.ANTHROPIC_FILES_URL}/{file_id}/content"
        response = await self.client.get(url, headers=self._get_headers())
        response.raise_for_status()
        content_type = response.headers.get("content-type", "application/octet-stream")
        return response.content, content_type
    
    async def upload_file(self, content: bytes, filename: str, content_type: str) -> str:
        """Upload a file to Claude Files API.
        
        Args:
            content: File content as bytes.
            filename: Name of the file.
            content_type: MIME type of the file.
            
        Returns:
            The Claude file ID.
        """
        headers = self._get_headers()
        del headers["Content-Type"]  # Let httpx set multipart content type
        
        files = {"file": (filename, content, content_type)}
        response = await self.client.post(
            self.ANTHROPIC_FILES_URL,
            headers=headers,
            files=files,
        )
        response.raise_for_status()
        data = response.json()
        return data["id"]
    
    async def generate_with_skills(
        self,
        messages: List[Dict[str, Any]],
        system_prompt: Optional[str] = None,
    ) -> AsyncGenerator[Dict[str, Any], None]:
        """Generate content using Claude Skills with streaming.
        
        This method streams SSE events from Claude and yields parsed events.
        It also detects file generation and includes file_ready events.
        
        Args:
            messages: List of message dicts with role and content.
            system_prompt: Optional system prompt.
            
        Yields:
            Parsed SSE events including custom file_ready events.
        """
        body = self._build_request_body(messages, system_prompt, stream=True)
        
        print(f"[Skills] Starting request with {len(messages)} messages")
        
        async with self.client.stream(
            "POST",
            self.ANTHROPIC_API_URL,
            headers=self._get_headers(),
            json=body,
        ) as response:
            response.raise_for_status()
            
            buffer = ""
            async for chunk in response.aiter_text():
                buffer += chunk
                
                # Process complete SSE events
                while "\n\n" in buffer:
                    event_str, buffer = buffer.split("\n\n", 1)
                    event = self._parse_sse_event(event_str)
                    
                    if event:
                        yield event
                        
                        # Check for file generation in tool results
                        file_info = self._extract_file_info(event)
                        if file_info:
                            print(f"[Skills] File detected: {file_info['file_name']} (id={file_info['file_id']})")
                            # Download the file and yield a file_ready event
                            try:
                                content, content_type = await self.download_file(file_info["file_id"])
                                skill = self._detect_skill_from_filename(file_info["file_name"])
                                
                                yield {
                                    "type": "file_ready",
                                    "file_id": file_info["file_id"],
                                    "file_name": file_info["file_name"],
                                    "content_base64": base64.b64encode(content).decode("utf-8"),
                                    "content_type": content_type,
                                    "skill": skill.value if skill else None,
                                    "size": len(content),
                                }
                                print(f"[Skills] File ready: {file_info['file_name']} ({len(content)} bytes)")
                            except Exception as e:
                                print(f"[Skills] Error downloading file: {e}")
                                yield {
                                    "type": "file_error",
                                    "file_id": file_info["file_id"],
                                    "file_name": file_info["file_name"],
                                    "error": str(e),
                                }
    
    def _parse_sse_event(self, event_str: str) -> Optional[Dict[str, Any]]:
        """Parse an SSE event string into a dict."""
        event_type = None
        data = None
        
        for line in event_str.split("\n"):
            line = line.strip()
            if line.startswith("event:"):
                event_type = line[6:].strip()
            elif line.startswith("data:"):
                data_str = line[5:].strip()
                if data_str:
                    try:
                        data = json.loads(data_str)
                    except json.JSONDecodeError:
                        data = data_str
        
        if data is not None:
            if isinstance(data, dict):
                if event_type:
                    data["_event_type"] = event_type
                return data
            return {"_event_type": event_type, "data": data}
        
        return None
    
    def _extract_file_info(self, event: Dict[str, Any]) -> Optional[Dict[str, str]]:
        """Extract file information from a tool result event.
        
        Looks for bash_code_execution_tool_result or text_editor_code_execution_tool_result
        events that contain a file_id.
        """
        event_type = event.get("type", "")
        
        # Check for content_block_start with tool result
        if event_type == "content_block_start":
            content_block = event.get("content_block", {})
            block_type = content_block.get("type", "")
            
            if block_type in ("bash_code_execution_tool_result", "text_editor_code_execution_tool_result"):
                content = content_block.get("content", {})
                
                # Check for file_id in content array
                if isinstance(content, dict) and "content" in content:
                    for item in content.get("content", []):
                        if isinstance(item, dict) and item.get("file_id"):
                            return {
                                "file_id": item["file_id"],
                                "file_name": item.get("file_name", f"generated_{item['file_id']}"),
                            }
                
                # Also check direct content items
                if isinstance(content, list):
                    for item in content:
                        if isinstance(item, dict) and item.get("file_id"):
                            return {
                                "file_id": item["file_id"],
                                "file_name": item.get("file_name", f"generated_{item['file_id']}"),
                            }
        
        # Check content_block_delta for streaming file info
        if event_type == "content_block_delta":
            delta = event.get("delta", {})
            delta_type = delta.get("type", "")
            
            if delta_type in ("bash_code_execution_output_delta", "code_execution_output"):
                if delta.get("file_id"):
                    return {
                        "file_id": delta["file_id"],
                        "file_name": delta.get("file_name", f"generated_{delta['file_id']}"),
                    }
        
        # Check for tool_result type events
        if event_type == "tool_result" or event.get("_event_type") == "tool_result":
            content = event.get("content", [])
            if isinstance(content, list):
                for item in content:
                    if isinstance(item, dict) and item.get("file_id"):
                        return {
                            "file_id": item["file_id"],
                            "file_name": item.get("file_name", f"generated_{item['file_id']}"),
                        }
        
        return None
    
    def _detect_skill_from_filename(self, filename: str) -> Optional[SkillType]:
        """Detect which skill was used based on file extension."""
        ext = filename.lower().split(".")[-1] if "." in filename else ""
        skill_map = {
            "xlsx": SkillType.XLSX,
            "pptx": SkillType.PPTX,
            "pdf": SkillType.PDF,
            "docx": SkillType.DOCX,
        }
        return skill_map.get(ext)
    
    async def close(self):
        """Close the HTTP client."""
        await self.client.aclose()


# Default system prompt for skills-enabled requests
SKILLS_SYSTEM_PROMPT = """You are a helpful AI assistant with document generation capabilities.

You can create professional documents in the following formats:
- **Excel spreadsheets** (.xlsx) - for data, tables, charts, and calculations
- **PowerPoint presentations** (.pptx) - for slides, presentations, and visual content
- **PDF documents** (.pdf) - for formatted reports and documents
- **Word documents** (.docx) - for text documents, reports, and letters

When asked to create a document:
1. Understand the user's requirements clearly
2. Use the code execution tool with the appropriate skill to generate the document
3. Provide a brief description of what you created

You have access to code execution for creating these documents. Use it when the user requests document generation.

Be thorough and create high-quality, professional documents that meet the user's needs."""


def get_skills_client() -> Optional[ClaudeSkillsClient]:
    """Get a configured Claude Skills client.
    
    Returns None if ANTHROPIC_API_KEY is not set.
    """
    api_key = os.getenv("ANTHROPIC_API_KEY")
    if not api_key:
        print("[Skills] Warning: ANTHROPIC_API_KEY not set, skills disabled")
        return None
    
    config = SkillsConfig(api_key=api_key)
    return ClaudeSkillsClient(config)


def is_document_generation_request(message: str) -> bool:
    """Check if a message is requesting document generation.
    
    This is a simple heuristic to detect document generation requests.
    Can be used to route requests to skills vs regular agent.
    """
    message_lower = message.lower()
    
    # Document type keywords
    doc_keywords = [
        "spreadsheet", "excel", "xlsx",
        "presentation", "powerpoint", "pptx", "slides",
        "pdf", "document", "report",
        "word", "docx",
    ]
    
    # Action keywords
    action_keywords = [
        "create", "generate", "make", "build",
        "write", "produce", "draft",
    ]
    
    has_doc_keyword = any(kw in message_lower for kw in doc_keywords)
    has_action_keyword = any(kw in message_lower for kw in action_keywords)
    
    return has_doc_keyword and has_action_keyword
